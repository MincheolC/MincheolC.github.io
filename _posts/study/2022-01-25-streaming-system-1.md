---
title: '스트리밍 시스템 1장'
excerpt: '1장. 스트리밍 101'
categories:
  - book
  
tags: [Streaming System, 스트리밍 시스템]
author_profile: true

toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true

date: 2022-01-25
---

본 글은 Tyler Akidau 외 2명이 지은 "스트리밍 시스템(Streaming System)"이라는 책의 1장 "스트리밍 101"을 읽고 정리한 글 입니다.
본문에 나오는 그림은 저자가 제공하는 그림을 사용했습니다. ([스트리밍 시스템 그림 모음집](http://www.streamingbook.net/fig))

- [들어가며](#들어가며)
- [용어](#용어)
  - [스트리밍 시스템](#스트리밍-시스템)
  - [마이크로 배치 시스템 (microbatch)](#마이크로-배치-시스템-microbatch)
  - [데이터셋의 기수](#데이터셋의-기수)
  - [데이터셋의 구성](#데이터셋의-구성)
  - [람다 아키텍처 (Lambda Architecture)](#람다-아키텍처-lambda-architecture)
  - [스트리밍 시스템이 배치 시스템을 이기기 위해서 무엇이 필요할까?](#스트리밍-시스템이-배치-시스템을-이기기-위해서-무엇이-필요할까)
    - [정확성 (correctness)](#정확성-correctness)
    - [시간 판단 도구 (tools for reasoning about time)](#시간-판단-도구-tools-for-reasoning-about-time)
  - [이벤트 시간과 처리 시간](#이벤트-시간과-처리-시간)
- [데이터 처리 패턴](#데이터-처리-패턴)
  - [유한 데이터](#유한-데이터)
  - [무한 데이터: 배치](#무한-데이터-배치)
    - [고정 윈도우 (fixed window, tumbling window)](#고정-윈도우-fixed-window-tumbling-window)
    - [세션 (session)](#세션-session)
  - [무한 데이터: 스트리밍](#무한-데이터-스트리밍)
    - [시간 무시](#시간-무시)
      - [필터링(filtering)](#필터링filtering)
      - [내부 조인(inner join)](#내부-조인inner-join)
    - [근사 알고리즘](#근사-알고리즘)
    - [윈도우](#윈도우)
      - [고정 윈도우(fixed window), 텀블링 윈도우 (tumbling window)](#고정-윈도우fixed-window-텀블링-윈도우-tumbling-window)
      - [슬라이딩 윈도우 (sliding window), 호핑 윈도우 (hopping window)](#슬라이딩-윈도우-sliding-window-호핑-윈도우-hopping-window)
      - [세션 (session)](#세션-session-1)
      - [처리시간 윈도우](#처리시간-윈도우)
      - [이벤트 시간 윈도우](#이벤트-시간-윈도우)


# 들어가며
스트리밍 데이터 처리(streaming data processing)이 주목 받는 이유는 무엇일까?
- **데이터에 대한 인사이트(insight)**를 얻을 수 있다.
- **대규모 무한 데이터셋(unbounded dataset)을 다룰** 수 있도록 설계된 시스템으로 쉽게 처리할 수 있다.
- 데이터가 도착하는 시점에 처리 될 수 있으면 시스템의 작업 부하가 고르게 분산되어 **좀 더 일관되고 예측 간으한 형태로 시스템 자원을 소비**할 수 있다.

# 용어
## 스트리밍 시스템
무한 데이터 셋(unbounded data)을 염두에 두고 설계된 처리 엔진의 유형을 말한다.

## 마이크로 배치 시스템 (microbatch)
무한 데이터를 처리하기 위해 배치 처리 엔진을 반복 실행하는 스트리밍 시스템이다.

> 데이터 셋의 모양을 정의하는 2가지 중요한 차원이 있다. 바로 기수(cardinality)와 구성(constitution)이며, 이 두 속성은 직교적(orthogonal)이다. (직교적이란 서로 독립적이란 의미다.)

## 데이터셋의 기수
**데이터 셋의 크기**를 뜻하며, 가장 두드러진 측면은 데이터 집합이 유한인지 무한인지를 결정하는 것이다. 기수를 사용하는데 설명할 때 사용하는 두 용어다.
- 유한 데이터 (bounded data): 크기가 유한한 데이터셋 유형을 말한다.
- 무한 데이터 (unbounded data): (최소한 이론적으로) 크기가 무한한 데이터셋 유형을 말한다.

기수가 중요한 이유는 무한함이라는 특성으로 인해 데이터 처리 프레임워크가 갖는 부담이 발생하기 때문이다.

## 데이터셋의 구성
**데이터의 물리적 표현**을 나타낸다.해당 데이터 셋과 상호작용할 수 있는 방법을 정의해준다. 크게 두 가지 형태의 구성이 있다.
- 테이블 (table): 특정 시점의 데이터셋에 대한 전체적인 뷰 (ex SQL 시스템)
- 스트림 (stream): 시간에 따라 변화하는 데이터셋의 요소 단위 뷰 (ex MapReduce 시스템)

## 람다 아키텍처 (Lambda Architecture)
동일한 계산을 수행하는 **배치 시스템과 스트리밍 시스템을 함께 운영**하는 것을 말한다. 스트리밍 시스템은 부정확한 결과지만 낮읒 지연 시간으로 제공하며, 얼마 후 배치 시스템이 최종적으로 정확한 결과를 보여주는 식으로 동작한다. 독립된 두 버전의 파이프라인을 구축하고 유지하고, 최종적으로 병합해야 해서 매우 번거로운 시스템이다.

> 배치 시스템은 기능상 잘 설계된 스트리밍 시스템의 부분 집합이라고 볼 수 있다.

## 스트리밍 시스템이 배치 시스템을 이기기 위해서 무엇이 필요할까?
### 정확성 (correctness)
- 배치와 동등하지기 위한 조건이다.
- 핵심은 일관성을 제공할 수 있는 스토리지(consistent storage)로 귀결된다.
  - 시간이 지남에 따라 영구 상태를 유지할 수 있는 **체크포인트(checkpoint)** 방법이 필요하다.
  - **강한 일관성**은 “**정확히 한 번 처리(exactly-once-processing)**” 을 지원하기 위해 반드시 필요하다.

### 시간 판단 도구 (tools for reasoning about time)
- 배치의 능력을 뛰어넘게 해주는 부분이다.
- **다양한 이벤트 시간 왜곡이 발생하는 상황**에서 **무한 비순서 데이터(unbounded unordered data)**를 처리할 때 반드시 필요하다.

## 이벤트 시간과 처리 시간
모든 데이터 처리 시스템에는 일반적으로 **두 형태의 시간 영역**이 있다.
- 이벤트 시간 (event time) - 이벤트가 실제로 발생한 시간
- 처리 시간 (processing time) - 이벤트가 처리 시스템에서 관측된 시간

시간에 따른 사용자 행동의 특성을 분석하거나 결제 관련 서비스나 이상 징후 감지 등과 같은 **대부분의 경우에 이벤트 시간은 중요**하다. 이상적인 상황이라면 이벤트 시간과 처리 시간은 항상 동일하지만, 현실은 그렇지 않다.

![그림 1-1](/assets/images/streaming_system/stsy_0101.png)

**시간 차이에 영향을 줄 수 있는 요소** 무엇이 있을까??
- 공유된 리소스로 인한 제약 (ex 네트워크 혼잡도, 공유 환경의 CPU 등)
- 분산 시스템의 로직, 경쟁 상황 같은 소프트웨어 상의 원인
- 데이터 자체의 특성들 (ex 키 분산, 전달되는 데이터 양이나 순서의 변화 등)

**무한함**이라는 특성을 다루기 위해 이런 시스템은 일반적으로 인입되는 데이터를 **윈도우(window)** 라는 단위로 잘라 다룰 수 있는 개념을 제공한다.

> 정확성과 이벤트 시간이 중요한 경우라면, 처리 시간 윈도우를 사용해 이 경계를 설정해서는 안 된다.
이벤트 시간 데이터 중 일부가 잘못된 처리 시간 윈도우로 들어가 정확성에 문제가 생길 수 있기 때문이다.

다수의 데이터 처리 시스템은 **데이터의 완결 시점에 의존**해 동작하며, 결국 무한 데이터셋에 적용될 경우 심각한 문제가 발생한다. 그렇기 때문에 저자들은 무한한 데이터를 완결성을 갖는 유한한 묶음으로 처리하려고 시도하는 대신 **복잡한 데이터 셋이 갖는 불확실성을 다룰 수 있는 도구를 설계**하는 것을 제안한다.

# 데이터 처리 패턴
## 유한 데이터
맵 리듀스와 같은 데이처 처리 엔진을 통해 처리한다.

![그림 1-2](/assets/images/streaming_system/stsy_0102.png)

## 무한 데이터: 배치
무한 데이터를 **배치 처리에 적합한 유한 데이터 셋의 집합으로 분할하는 것**이 중요하다.

### 고정 윈도우 (fixed window, tumbling window)
입력 데이터를 고정된 크기로 잘라 유한 데이터 소스처럼 처리한다.

![그림 1-3](/assets/images/streaming_system/stsy_0103.png)

데이터 입력이 완결됐음을 알리는 완결성(complete) 문제가 남아 있다. 
- 모든 이벤트 수집을 확인할 때까지 처리를 지연하거나 
- 데이터가 늦게 도착하면 소속될 윈도우에 대한 배치만 재실행

과 같은 방법으로 문제의 영향을 완화시킬 수 있지만 완벽한 해결책은 아니다.

### 세션 (session)
더 정교한 윈도우 전략으로, 세션의 활동(activity) 기간 (ex. 사용자 활동 기간)으로 정의되며, 일정 크기의 세션의 비활동 간격(inactivity gap)이 따라오면 끝난 것으로 간주한다.

![그림 1-4](/assets/images/streaming_system/stsy_0104.png)

고전적인 배치 엔진을 사용해 세션을 계산하는 것은 바람직하지 않다.
- 여러 배치로 나뉜 세션이 나타남
- 이전 배치에 나온 세션을 묶어주기 위한 로직이 필요

## 무한 데이터: 스트리밍
스트리밍 시스템은 아래과 같은 데이터들을 다룬다.
- 무한 데이터
- 이벤트 시간 기준으로 심하게 뒤섞여 이벤트 시간을 기준으로 처리하려면 파이프라인에서 **시간 기반의 셔플을 수행해야하는 데이터**
- 다양한 형태의 이벤트 타임 왜곡이 발생해 상수 **시간 범위 안에 주어진 시간 X의 대부분의 데이터를 봤다고 확신**할 수 없는 데이터

이와 같은 데이터를 다룰 때 취할 수 있는 몇 가지 접근법이 있다.
- **시간 무시 (time-agnostic)**
- **근사 (approximation)**
- **처리 시간 윈도우 (processing time window)**
- **이벤트 시간 윈도우 (event time window)**

### 시간 무시
시간이 본질적으로 무관한 경우, 즉 데이터 처리의 모든 결정을 데이터만 보면서 할 수 있을 때 사용한다. 모든 결정은 데이터가 도착하면서 이뤄지기 때문에, 스트리밍 엔진은 **데이터 전달 목적**으로만 사용된다. 배치 시스템 역시 무한 데이터 시간 무시 처리에 적합하다. 다음과 같은 예가 있다.

#### 필터링(filtering)
![그림 1-5](/assets/images/streaming_system/stsy_0105.png)

#### 내부 조인(inner join)
조인의 결과만 중요한 경우 시간적 요소 고려할 필요 없다. 짝을 못 만난 결과를 정리하기 위한 가비지 컬렉션 정책이 필요할 수도 있다.

![그림 1-6](/assets/images/streaming_system/stsy_0106.png)

> 처리 방법을 외부 조인으로 전환하면 데이터의 완결성 문제가 발생한다. 외부 조인은 내부 조인과 다르게 데이터의 다른 쪽이 없어도 흘려 보냄.

### 근사 알고리즘
Top-N, 스트리밍 k-평균 등을 예로 들 수 있다. (ex 유투브 알고리즘, 영상 군집화)

![그림 1-7](/assets/images/streaming_system/stsy_0107.png)

- 설계상 낮은 오버헤드를 갖고 무한 데이터를 고려해 설계됐다는 것이 장점이다.
- 알고리즘의 종류가 많지 않고 종종 알고리즘 자체가 복잡하며, 근사적인 특성으로 인해 유용성이 떨어질 수 있다는 것이 단점이다.
- 이런 알고리즘은 보통 설계 자체에 시간적인 요소를 포함한다는 점에 주목할 필요가 있음. (ex 내부 감쇠; built-in decay)
- **도착하는 순서대로 데이터를 처리**하기 때문에 이 때의 **시간적인 요소는 보통 처리 시간을 기준으**로 이루어진다. 이 사실(도착 순서로 처리)은 근사 결과에 대한 증명 가능한 오차 범위를 제공하는 알고리즘의 경우 특히 중요하다!

### 윈도우  
유한 또는 무한 데이터 소스를 가져와 처리를 위해 시간 경계를 따라 유한한 크기의 조각으로 자르는 개념이다.

![그림 1-8](/assets/images/streaming_system/stsy_0108.png)

#### 고정 윈도우(fixed window), 텀블링 윈도우 (tumbling window)
- 시간을 고정된 크기로 자름
- 일반적으로 전체 데이터셋을 **균일하게 잘라** **정렬 윈도우** 형태를 갖음.
- 윈도우 구성이 **완료되는 시점을 고르게 분산(성능 향상)** 하기 위해 **시간이 어긋**나도록 윈도우 적용하기도 함. → **비정렬 윈도우** 형태
        
#### 슬라이딩 윈도우 (sliding window), 호핑 윈도우 (hopping window)
고정 윈도우의 일반화된 형태로 **일정한 길이와 일정한 주기로 정의**됨.
- 주기 < 길이 = 겹침
- 주기 > 길이 = 샘플링
- 주기 = 길이 = 고정
  
#### 세션 (session)
- **동적 윈도우, 비정렬 윈도우**의 한 예.
- 일정 타임아웃 시간보다 긴 길이를 갖는 비활성화 간격으로 구분해 일련의 연속된 이벤트들을 묶어서 윈도우를 구성함.
- 세션은 보통 **시간적으로 관련돼 있는 이벤트를 묶어**서 시간에 따른 사용자의 행동을 분석하기 위해 사용 함.
- 실제 들어오는 데이터와 직접적으로 연관 → **길이가 미리 정해질 수 없음**.

#### 처리시간 윈도우
- 어느 정도의 처리 시간이 지날 때까지 들어오는 데이터를 버퍼링함.
    - 5분 길의 고정 윈도우 → 5분 동안 버퍼링
- 장점
    - 단순하다 (**시간 기준의 셔플링x**)
    - 윈도우가 완료되는 시점을 판단하기 쉬움 (**지연된 데이터를 다룰 필요x**)
    - 데이터 소스가 **관측되는 시점을 기준으로 정보를 추론**하고자 하는 경우, 처리 시간 윈도우가 적합.
        - ex 운영 중단을 감지하기 위해 글로벌 규모의 웹서비스의 초당 요청 개수를 모니터링 하는 경우
- 단점
    - 데이터가 이벤트 시간을 가지고 있어 실제 이벤트가 발생한 순서대로 반영되어야 하는 경우 힘듬. → **현재 데이터와 과거 데이터가 섞임**
        - ex1) 사용 통계를 수집하는 모바일 앱이 일정 기간 동안 오프라인 상태였다가 온라인으로 돌아온 경우 → 시간 왜곡이 생김. → 유의미한 결과를 도출하기 힘듬.
        - ex2) 여러 대륙에 걸쳐 수집된 데이터는 네트워크 문제로 인해 심한 시간 왜곡을 갖을 수 있음.
  
#### 이벤트 시간 윈도우
- 이벤트가 실제 발생한 시간을 반영해 유한한 크기의 조각으로 데이터 소스를 관찰하고자 할 때 사용.
- 장점
    - 세션 같은 **동적인 크기를 갖는 윈도우를 만들 수 있음**. (고정 윈도우에 걸친 세션을 분할할 필요x)
- 단점
    - 버퍼링
        - 윈도우 수명이 길어짐에 따라 더 많은 데이터를 버퍼링할 필요가 생김 → 강한 일관성을 위해 영구적인 상태 보존과 적절한 메모리 캐싱을 제공하는 시스템에서는 큰 문제x
        - 집계 방식 중 다수(합, 평균) 등은 모두를 버퍼링 할 필요 없이 점진적으로 결과를 낼 수 있음.
    - 완결성
        - 윈도우의 결과가 언제 구체화(materalize)될 지 알 수 없음.
        - 데이터 처리 시스템은 많은 입력 유형에 대해 **윈도우 완료를 결정하는 비교적 정확한 휴리스틱을 제공**할 수 있음 ← **워터마크(watermark)를 통해 사용 가능**.