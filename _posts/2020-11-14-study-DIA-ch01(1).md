---
title: '데이터 중심의 어플리케이션 설계 1장'
excerpt: '1장 "신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"을 정리한 글'
categories:
  - study
toc: true
---

본 글은 Martin Kleppmann(마틴 클레프만)이 지은 "데이터 중심 어플리케이션 설계"라는 책을 공부하며 정리한 내용이다. 책의 내용 중 1장 "신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"의 **신뢰성과 확장성**에 대해 정리한 글이다.

> 오늘날 많은 애플리케이션은 계산 중심(compute-intensive)와 다르게 데이터 **중심(data-intensive)적**이다. 이러한 애플리케이션의 경우 CPU 성능은 더 이상 애플리케이션을 제한하는 요소가 아니며, **더 큰 문제는 데이터의 양, 데이터의 복잡도, 데이터 변화 속도**이다. 이 책은 데이터 시스템의 원칙과 실용성, 그리고 이를 활용한 데이터 중심 애플리케이션을 개발하는 방법을 모두 담고 있다. -마틴 클레프만-

일반적으로 데이터 중심 어플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소(standard building block)으로 만든다.

- 데이터를 저장 (데이터베이스)
- 값비싼 수행 결과를 기억(캐시)
- 키워드 검색 또는 다양한 방법의 데이터 필터링 제공 (검색 색인)
- 비동기 처리를 위해 다른 프로세스로 메세지 보내기 (스트림 처리)
- 주기적으로 대량의 누적된 데이터를 분석 (일괄 처리)

너무나 뻔한 말처럼 들린다면 이는 언제나 많은 생각 없이 사용할 수 있게 데이터 시스템이 잘 추상화됐기 때문이다. 우리는 애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야한다.

이 책은 데이터 시스템 원칙과 실용성, 그리고 이를 활용한 데이터 중심 애플리케이션을 개발하는 방법을 모두 담고 있다. 이 책에서 소개된 다양한 도구가 공통으로 지닌 것은 무엇이고 서로 구별되는 것은 무엇인지, 그리고 어떻게 그러한 특성을 구현해냈는지 알아본다.

## 데이터 시스템에 대한 생각

데이터 저장과 처리를 위한 새로운 도구들은 최근에 만들어졌고 다양한 사용 사례에 최적화 됐기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다. 즉, 분류 간 경계가 흐려지고 있다.
또한 점점 더 많은 애플리케이션들이 단일 도구로는 더 이상 데이터 처리와 저장을 모두 해결할 수 없는 과도하고 광범위한 요구사항을 가지고 있기 떄문에, 작업(work)을 여러 태스크(task)로 나누고 이를 다양한 단일 도구로 처리한다.

이와 같은 변화로 인해 이제는 DB, 큐, 캐시 등 서로 다른 범주에 속하는 도구들을 **데이터 시스템**이라는 포괄적 용어로 묶어야 한다.

이제 **개발자는 애플리케이션 개발자뿐만 아니라 데이터 시스템 설계자**이기도 하다. 우리는 좋은 데이터 시스템이나 서비스를 설계할 때 여러가지 고민을 해야한다.

- 내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지하려면 어떻게 해야할까?
- 시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 어떻게 제공할 수 있을까?
- 부하 증가를 다루기 위해 어떻게 규모를 확장할까?
- 서비스를 위해 좋은 API는 어떤 모습일까?

이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.

- 신뢰성 (Reliabilty)
- 확장성 (Scalability)
- 유지보수성 (Maintainability)

## 신뢰성

> 하드웨어나 소프트웨어 결함. 심지어 인적 오류(human error)같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야한다.

**결함(Fault)**은 잘못될 수 있는 일을 의미한다. 결함을 예측하고 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient)을 지녔다고 말한다. 결함과 **장애(failure)**은 다르다. 일반적으로 결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다. **결함을 0으로 줄이는 것은 불가능하기 때문에 결함으로 인해 장개가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다**.

고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있다는 자신감을 높인다. **Netflix의 [Chaos Monkey](https://netflix.github.io/chaosmonkey/)**가 이런 접근 방식의 예이다.

### 하드웨어 결함

하드디스크 고장, 램 결함, 대규모 정전 사태 등을 말한다. 이를 해결하기 위해 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있다. 이런 시스템은 장비를 재부팅해야 하는 경우(예를 들어 운영체제 보안패치를 적용) 전체 시스템의 중단시간 없이 한 번에 한 노드씩 패치할 수 있는 점과 같은 운영상의 장점이 있다.

### 소프트웨어 오류

잘못된 특정 입력에 모든 서버가 죽는 버그, 공유 자원을 과도하게 사용하는 일부 프로세스, 연쇄 장애 등의 시스템 내 체계적 오류(systematic error)를 말한다. 이 결함은 예상하기 어렵고 노드 간 상관관계 때문에 하드웨어 결함보다 오히려 시스템 오류를 더 유발하는 경향이 있다.

소프트웨어 오류를 해결하기 위한 신속한 해결책은 없다. 아래와 같은 여러 작은 일들이 문제 해결에 도움을 준다.

- 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기
- 빈틈없는 테스트
- 프로세스 격리(process isolation)
- 모니터링 및 분석하기

### 인적 오류

운영자의 설정 오류 등과 같이 사람의 실수로 인해 발생하는 오류를 말한다. 인적 오류는 아래와 같은 방법으로 보완할 수 있다.

- 오류의 가능성을 최소화하는 방향으로 시스템을 설계하기
- 사람이 가장 많이 실수하는 부분에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하기
- 철저하게 테스트하기
- 인적 오류를 빠르고 쉽게 복구할 수 있게 하기

## 확장성

> 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.

확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는데 사용하는 용어로 **확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?", "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?" 와 같은 질문을 고려한다는 의미**다.

### 부하 기술하기

무엇보다 시스템의 현재 부하를 간결하게 기술해야 한다. 그래야 부하 성장 질문(부하가 두 배로 되면 어떻게 될까?)을 논의할 수 있다. 부하는 웹 서버의 초당 요청 수, DB 읽기 대 쓰기 비율, Active user수, 캐시 적중률 등과 같은 **부하** **매개변수(load parameter)**로 나타낼 수 있다.

### 성능 기술하기

시스템의 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다. 다음 두가지 방법으로 살펴볼 수 있다.

- 부하 매개 변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 늘려야 할까?

하둡(Hadoop)과 같은 일괄 처리 시스템 보통 처리량(throughput)에 관심을 가진다. 온라인 시스템에서는 서비스 응답 시간(response time)에 더 관심을 가진다.

동일한 요청을 하더라도 매번 응답 시간이 다르다. 때문에 **응답 시간은 단일 숫자(평균)보다는 측정 가능한 값의 분포로 생각해야 한다**. 즉, 백분위(percentile)을 사용하는 편이 더 좋다.

**백분위 예**

- p50 - 50분위
- p95 - 95분위
- p99 - 99분위

**꼬리 지연 시간(tail latency)로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다.** 백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 자주 사용한다.

### 부하 대응 접근 방식

부하 매개변수가 어느 정도 증가하더라도 좋은 성능을 유지하려면 어떻게 해야 할까?

일반적으로 **용량 확장(scaling up; 수직 확장(vertical scaling)**, 좀 더 강력한 장비로 이동)과 **규모 확장(scaling out; 수평 확장(horizontal scaling)**, 다수의 낮은 사양 장비에 부하를 분산)으로 구분해서 말한다.

특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다.

## 유지보수성

> 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영)할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.

소프트웨어 비용은 대부분 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어간다는 사실은 잘 알려져 있다. 이런 유지보수에는 버그 수정, 시스템 운영 쥬지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 새로운 기능 추가 등이 있다. 대게 사람들은 **레거시** 시스템 유지보수 작업을 좋아하지 않는다.

유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프트웨어를 설계하려면 어떻게 해야할까?

답은 다음 3가지 소프트웨어 시스템 설계 원칙을 염두에 두고 시스템을 설계해야한다.

### 운용성(operability)

> 운영팀이 시스템을 원할하게 운영할 수 있게 쉽게 만들어라

운영을 자동화해라. 시스템이 지속해서 원활하게 작동하려면 운영팀이 필수다. 좋은 운영팀은 다음과 같은 작업 등을 책임진다.

- 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
- 시스템 장애, 성능 저하 등의 문제 원인을 추적
- 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
- 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 미리 차단
- 미래에 발생 가능한 문제를 예측해 미리 해결 (용량 계획)
- 배포, 설정 관리 등을 위한 모범 사례와 도구 마련
- 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
- 개인 인사 이동에도 문제 없도록 시스템에 대한 조직의 지식을 보존함.

**좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미**이다. 반복 태스크를 쉽게 하기 위해 아래 항목 등을 포함해 다양한 일을 할 수 있다.

- 좋은 모니터링으로 런타임 동작과 시스템 내부에 대한 가시성 제공
- 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원 제공
- 좋은 문서와 이해하기 쉬운 운영 모델 제공
- 적절하게 자기 회복이 가능할 뿐만 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함.

### 단순성(simplicity)

> 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하게 쉽게 만들어라

프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워진다. 복잡도는 다양한 증상으로 나타난다.

- 상태공간의 급증
- 모듈 간 강한 커플링
- 일관성 없는 naming과 용어
- 임시방편으로 문제를 해결한 특수 사례
- etc

복잡도 때문에 시스템 유지보수가 어려워지면 예산과 일정이 초과되곤 한다. 또한 변경 시 버그가 생길 위험이 더 크며, 시스템에 숨겨진 가정과 의도치 않은 결과 등을 간과하기 쉽다. 때문에 시스템을 단순하게 만드는 일은 매우 중요하다.

시스템을 단순하게 만드는 일이 반드시 기능을 줄인다는 의미는 아니다. 우발적 복잡도(accidental complexity)를 줄인다는 뜻일 수도 있다.

> 우발적 복잡도(accidental complexity)란 시스템이 보기 흉하게 설계된 인터페이스로 디자인되어 발생되는 복잡도를 의미한다. -wiki.c2.com-

우발적 복잡도를 제거하기 위한 최상의 도구는 **추상화**이다. 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.

### 발전성(evolvability)

> 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경 같은 예기치 않은 사용 사례를 적용하기가 쉽다. 이 속성은 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)로 알려져 있다.

## Reference

- [데이터 중심 애플리케이션 설계](http://www.yes24.com/Product/Goods/59566585)
- [Accidental Complexity](https://wiki.c2.com/?AccidentalComplexity)
